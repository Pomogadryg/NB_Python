import xlrd
from docx import Document
import sys
import random
from tkinter import *
from tkinter import ttk
import sqlite3
from tkinter import messagebox
from googletrans import Translator
from selenium import webdriver
from selenium.webdriver.common.keys import Keys
from PyDictionary import PyDictionary
from tkinter import colorchooser
import math
# search mayusculas y menusculas -DONE
# check the new table and compare with the old one -DONE
# possibility to add new lines - in progress


class Create_check_db(object):
    def __init__(self, loc_V1, loc_V3, loc_Voc_comp):
        self.loc_V1 = loc_V1
        self.loc_V3 = loc_V3
        self.loc_Voc_comp = loc_Voc_comp
        # self.Create()  # - update DB
        # self.Check_Combine_db()

    def Create(self):
        conn = sqlite3.connect(self.loc_V3)
        c = conn.cursor()

        c.execute("""CREATE TABLE voc_table(
        id_ integer,
        rus_ text,
        eng_ text,
        esp_ text)""")
        idx = 0

        wordDoc = Document(self.loc_Voc_comp)
        for table in wordDoc.tables:
            for row in table.rows:
                list_ = []

                for cell in row.cells:
                    temp_ = ''
                    for ch in cell.text:
                        if ord(ch) in range(65000):
                            temp_ = temp_ + ch

                    try:
                        list_.append(temp_)
                    except:
                        None
                if len(list_) == 3:
                    c.execute("INSERT INTO voc_table VALUES (?,?,?,?)", (idx, list_[0], list_[1], list_[2]))
                    idx += 1
                elif len(list_) == 2:
                    c.execute("INSERT INTO voc_table VALUES (?,?,?,?)", (idx, list_[0], list_[1], 'None'))
                    idx += 1
                conn.commit()

    def Check_Combine_db(self):
        conn = sqlite3.connect(self.loc_V1)
        c = conn.cursor()
        conn2 = sqlite3.connect(self.loc_V3)
        c2 = conn2.cursor()
        c.execute("SELECT* FROM voc_table")
        c2.execute("SELECT* FROM voc_table")
        list_to1 = []
        list_to2 = []
        total = []
        for st in c.fetchall():
            list_to1.append(st)

        for st in c2.fetchall():
            list_to2.append(st)
        for ln2 in list_to2:
            match = False
            for ln1 in list_to1:
                if ln1[1] == ln2[1]:
                    match = True
                    break
            if match == False:
                total.append(ln2)

        print('Lines were changed: ', total)
        for st in total:
            if len(st) == 4:
                c.execute("INSERT INTO voc_table VALUES(?,?,?,?)", (st[0], st[1], st[2], st[3]))
            elif len(st) == 3:
                c.execute("INSERT INTO voc_table VALUES(?,?,?,?)", (st[0], st[1], st[2], 'To be added'))
        conn.commit()
        conn2.commit()


class Select_text(object):
    def __init__(self, graph_):
        self.graph_ = graph_
        self.translator = Translator()
        self.vocab = PyDictionary()

    def method_rus_esp(self):
        selected = self.graph_.text_rus.get(SEL_FIRST, SEL_LAST)
        transl_from_rus_esp = self.translator.translate(selected, dest='es')
        self.graph_.text_esp.insert(INSERT, '\n\n%s' % transl_from_rus_esp.text)

    def method_eng_esp(self):
        selected = self.graph_.text_eng.get(SEL_FIRST, SEL_LAST)
        transl_from_eng_esp = self.translator.translate(selected, dest='es')
        self.graph_.text_esp.insert(INSERT, '\n\n%s' % transl_from_eng_esp.text)
        # self.getBrowser(selected)
        meaning = self.vocab.meaning(selected)
        try:
            self.graph_.text_eng.insert('end', '\n\n')
            self.graph_.text_eng.insert('end', '--------------')
            self.graph_.text_eng.insert('end', '\n')
            self.graph_.text_eng.insert('end', 'Noun:  ')
            self.graph_.text_eng.insert('end', meaning['Noun'])
            self.graph_.text_eng.insert('end', '\n\n')
            self.graph_.text_eng.insert('end', '--------------')
            self.graph_.text_eng.insert('end', '\n')
            self.graph_.text_eng.insert('end', 'Verb:  ')
            self.graph_.text_eng.insert('end', meaning['Verb'])
            self.graph_.text_eng.insert('end', '\n\n')
            self.graph_.text_eng.insert('end', '--------------')
            self.graph_.text_eng.insert('end', '\n')
            self.graph_.text_eng.insert('end', 'Adjective:  ')
            self.graph_.text_eng.insert('end', meaning['Adjective'])
        except:
            pass

    def getBrowser(self, selected):
        driver = webdriver.Chrome()
        driver.get(r'https://translate.google.com/?hl=es')
        text_form = driver.find_element_by_id('source')
        text_form.send_keys(selected)
        text_form.send_keys(Keys.RETURN)
        all_elements = driver.find_elements_by_xpath("//*[@id]")
        for i in all_elements:
            if 'Traducciones' in i.text:
                match = i.text
                break
        try:
            match = match.split(' ')
        except:
            print('no words')
        defin = ''
        trad = ''
        t = False
        d = False
        inf = False
        ver = False
        for i in range(len(match)):
            if 'Definiciones' in match[i]:
                d = True
                continue
            if 'Traducciones' in match[i]:
                t = True
                d = False
                continue
            if 'Información' in match[i]:
                t = False
                d = False

            if d:
                defin = defin + match[i] + ' '
            elif t:
                trad = trad + match[i] + ' '

        list_def = []
        list_trad = []

        defin = defin.split('\n')
        trad = trad.split('\n')
        a = 0
        for w in defin:
            if 'definiciones' in w:
                break

            if len(w):
                a += 1
                if a >= 2:
                    print(w)

        print('----------')
        b = 0
        new_list = []
        for w in trad:
            if len(w):
                b += 1
                if b >= 2:
                    print(w.replace('\n', ' '))

        driver.close()


class Graph(object):
    def __init__(self, master):

        self.color = 0
        self.sel = StringVar()
        self.fav_sel = StringVar()
        self.goBack = StringVar()
        self.Color_select = StringVar()

        self.master = master
        self.master.config(bg='powder blue')
        self.text_rus = Text(self.master, width=25, height=15, wrap='word', bg='old lace')
        self.text_rus.place(x=10, y=100)

        self.text_eng = Text(self.master, width=25, height=15, wrap='word', bg='old lace')
        self.text_eng.place(x=240, y=100)

        self.text_esp = Text(self.master, width=25, height=15, wrap='word', bg='old lace')
        self.text_esp.place(x=470, y=100)

        self.word_ = W0rd(self)
        self.f_word = Favorits(self)
        self.edit_ = Edit_(self)
        self.sel_txt = Select_text(self)

        self.master.protocol("WM_DELETE_WINDOW", self.f_word.on_closing)
        self.master.bind('<Escape>', lambda e: self.f_word.on_closing())

        self.b_continue = Button(self.master, text='Continue', command=self.word_.getWord)
        self.b_continue.place(relx=0.01, y=400, width=150)

        self.text_rus.bind('<Double-Button-1>', lambda e: self.word_.getWord())

        self.color_combo = ttk.Combobox(self.master, textvariable=self.Color_select,values=('Blue','Green','Red','White'))
        self.color_combo.place(relx=0.01, rely=0.01)

        # self.b_back = Button(self.master, text='<---- Back', command=self.backwards)
        # self.b_back.place(relx=0.39, y=400, width=150)

        self.master.bind('<F1>', lambda e: self.sel_txt.method_rus_esp())
        self.master.bind('<F2>', lambda e: self.sel_txt.method_eng_esp())

        self.b_search = Button(self.master, text=' (¬_¬) <SEARCH>  ಠ_ಠ ', command=self.search_)
        self.b_search.place(relx=0.77, y=400, width=150)

        self.b_color = Button(self.master, text='_color_', command=self.color_apply)
        self.b_color.place(relx=0.35, y=400, width=150)

        self.Frase_button = ttk.Checkbutton(self.master, text='Frases')
        self.Frase_button.place(x=20, y=60)
        self.Frase_button.config(variable=self.sel, onvalue='True', offvalue='False')

        self.Back_checkbox = ttk.Checkbutton(self.master, text='GoBack')
        self.Back_checkbox.place(x=20, y=37)
        self.Back_checkbox.config(variable=self.goBack, onvalue='True', offvalue='False')

        self.Fav_button = ttk.Checkbutton(self.master, text='Favoritos')
        self.Fav_button.place(x=450, y=60)
        self.Fav_button.config(variable=self.fav_sel, onvalue='True', offvalue='False')

        self.b_fav_add = Button(self.master, text=' Añadir ', command=self.f_word.add_)
        self.b_fav_add.place(relx=0.75, y=60, width=80)

        self.b_fav_rem = Button(self.master, text=' Quitar ', command=self.f_word.rem_)
        self.b_fav_rem.place(relx=0.87, y=60, width=80)

        self.edit_esp_button = Button(self.text_esp, text=' editar ', command=self.edit_.generic_func)
        self.edit_esp_button.place(relx=0.9, x=-30, rely=0.94, y=-10, width=50)

    def search_(self):
        idx_srch = []
        s_ch = self.text_rus.get('1.0', 'end')
        s_ch = s_ch.strip()
        for words in self.word_.search_list_rus:
            if 'Frases' not in words:
                if (s_ch in words) or (s_ch.title() in words):
                    idx = self.word_.search_list_rus.index(words)
                    idx_srch.append(idx)
        for words in self.word_.search_list_eng:
            if (s_ch in words) or (s_ch.title() in words):
                idx = self.word_.search_list_eng.index(words)
                idx_srch.append(idx)

        for words in self.word_.search_list_esp:
            if (s_ch in words) or (s_ch.title() in words):
                idx = self.word_.search_list_esp.index(words)
                idx_srch.append(idx)

        try:
            self.text_rus.delete('1.0', 'end')
            self.text_eng.delete('1.0', 'end')
            self.text_esp.delete('1.0', 'end')
        except:
            None
        count = 1
        for i in idx_srch:
            self.text_rus.insert(INSERT, '%d)  ' % count + self.word_.search_list_rus[i])
            self.text_rus.insert(INSERT, '\n ===============\n')

            self.text_eng.insert(INSERT, '%d)  ' % count + self.word_.search_list_eng[i])
            self.text_eng.insert(INSERT, '\n ===============\n')
            self.text_esp.insert(INSERT, '%d)  ' % count + self.word_.search_list_esp[i])
            self.text_esp.insert(INSERT, '\n ===============\n')
            count += 1

    def color_apply(self):

        #'Blue' - '#46a3ff','Green' - '#00c100','Red' - '#ff4242','White' - '#ffffff'
        #self.color = colorchooser.askcolor(initialcolor='#FFFFFF')  # this opens the color table




        if self.Color_select.get()=='Blue':
            sel_first_index=(self.text_rus.index(SEL_FIRST))
            self.text_rus.insert(sel_first_index,'[')
            sel_last_index=(self.text_rus.index(SEL_LAST))
            self.text_rus.insert(sel_last_index,'´´')
            self.text_rus.tag_add('blue',sel_first_index,sel_last_index)




        elif self.Color_select.get()=='Green':
            sel_first_index=(self.text_rus.index(SEL_FIRST))
            self.text_rus.insert(sel_first_index,'´')
            sel_last_index=(self.text_rus.index(SEL_LAST))
            self.text_rus.insert(sel_last_index,'´')
            self.text_rus.tag_add('green',sel_first_index,sel_last_index)


        self.text_rus.tag_config('blue',background='lightblue',foreground='black')
        self.text_rus.tag_config('green',background='lightgreen',foreground='black')





class Edit_(object):
    def __init__(self, graph_):
        self.graph_ = graph_

    def generic_func(self):
        self.edit_rus()
        self.edit_eng()
        self.edit_esp()

    def edit_rus(self):
        to_modif_rus = (self.graph_.text_rus.get('1.0', 'end'))
        if self.graph_.word_.rnd_for_continue == self.graph_.word_.total_count[self.graph_.word_.ind_backwards]:
            idx = (self.graph_.word_.rnd_for_continue)
            print('rus if: ', idx)
        else:
            idx = self.graph_.word_.total_count[self.graph_.word_.ind_backwards + 1]
            print('rus else: ', idx)
        conn = sqlite3.connect('C:/C/V1.db')
        c = conn.cursor()
        c.execute("UPDATE voc_table SET rus_=? WHERE rowid=?", (to_modif_rus, idx))
        conn.commit()

    def edit_eng(self):
        to_modif_eng = (self.graph_.text_eng.get('1.0', 'end'))
        if self.graph_.word_.rnd_for_continue == self.graph_.word_.total_count[self.graph_.word_.ind_backwards]:
            idx = (self.graph_.word_.rnd_for_continue)
            print('eng if: ', idx)
        else:
            idx = self.graph_.word_.total_count[self.graph_.word_.ind_backwards + 1]
            print('eng else: ', idx)
        conn = sqlite3.connect('C:/C/V1.db')
        c = conn.cursor()
        c.execute("UPDATE voc_table SET eng_=? WHERE rowid=?", (to_modif_eng, idx))
        conn.commit()

    def edit_esp(self):
        to_modif_esp = (self.graph_.text_esp.get('1.0', 'end'))
        if self.graph_.word_.rnd_for_continue == self.graph_.word_.total_count[self.graph_.word_.ind_backwards]:
            idx = (self.graph_.word_.rnd_for_continue)
            print('esp if: ', idx)
        else:
            idx = self.graph_.word_.total_count[self.graph_.word_.ind_backwards + 1]
            print('esp else: ', idx)

        conn = sqlite3.connect('C:/C/V1.db')
        c = conn.cursor()
        c.execute("UPDATE voc_table SET esp_=? WHERE rowid=?", (to_modif_esp, idx))
        conn.commit()


class Favorits(object):
    def __init__(self, graph_):
        self.fav_list = []
        self.graph_ = graph_
        self.conn3 = sqlite3.connect('C:/C/V2.db')
        self.c3 = self.conn3.cursor()
        self.c3.execute("SELECT * FROM fav")
        for w in self.c3.fetchall():
            self.fav_list.append(w)

    def add_(self):

        to_add_rus = self.graph_.text_rus.get('1.0', 'end')
        to_add_eng = self.graph_.text_eng.get('1.0', 'end')
        to_add_esp = self.graph_.text_esp.get('1.0', 'end')

        self.fav_list.append((len(self.fav_list), to_add_rus, to_add_eng, to_add_eng))

    def rem_(self):
        idx = (self.graph_.word_.f_0_to_remove)
        for w in self.fav_list:
            if idx == w:
                self.fav_list.remove(w)

    def on_closing(self):
        if messagebox.askokcancel("Quit", "Do you want to quit?"):
            self.c3.execute("DELETE FROM fav")
            for w in self.fav_list:
                self.c3.execute("INSERT INTO fav VALUES(?,?,?,?)", (w[0], w[1], w[2], w[3]))
            self.conn3.commit()
            self.graph_.master.destroy()


class W0rd(object):
    def __init__(self, graph_):
        self.rnd_for_continue = 0
        self.ind_backwards = -1
        self.rnd_fav = 0
        self.f_0_to_remove = []
        self.graph_ = graph_
        self.total_count = []
        self.conn = sqlite3.connect(r'C:/C/V1.db')
        self.conn_frases = sqlite3.connect(':memory:')
        self.conn_favorits = sqlite3.connect('C:/C/V2.db')
        self.c = self.conn.cursor()
        self.c_frases = self.conn_frases.cursor()
        self.c_frases.execute("CREATE TABLE frases_words(id_,rus_f,eng_f)")
        self.c_favorits = self.conn_favorits.cursor()
        self.search_list_rus = []
        self.search_list_eng = []
        self.search_list_esp = []
        self.c.execute("select *from voc_table")
        for w in self.c.fetchall():
            if 'Frases' in w[1]:
                self.c_frases.execute("INSERT INTO frases_words VALUES(?,?,?)", (w[0], w[1], w[2]))
                self.conn_frases.commit()

            if len(w) == 4:
                self.search_list_rus.append(w[1])
                self.search_list_eng.append(w[2])
                self.search_list_esp.append(w[3])
            elif len(w) == 3:
                self.search_list_rus.append(w[1])
                self.search_list_eng.append(w[2])
                self.search_list_esp.append('None')

    def getWord(self):

        if (self.graph_.sel.get()) == 'True':

            self.c_frases.execute("SELECT Count(*) FROM frases_words")
            frase_lim = self.c_frases.fetchall()
            rnd = random.randint(1, frase_lim[0][0])
            self.graph_.text_rus.delete('1.0', 'end')
            self.graph_.text_esp.delete('1.0', 'end')
            self.graph_.text_eng.delete('1.0', 'end')
            self.c_frases.execute("select *from frases_words where rowid=%d" % rnd)
            f = (self.c_frases.fetchone())
            self.graph_.text_rus.insert('1.0', f[1])

        elif (self.graph_.fav_sel.get()) == 'True':

            rnd = random.randint(0, len(self.graph_.f_word.fav_list) - 1)
            self.f_0_to_remove = self.graph_.f_word.fav_list[rnd]

            self.graph_.text_rus.delete('1.0', 'end')
            self.graph_.text_esp.delete('1.0', 'end')
            self.graph_.text_eng.delete('1.0', 'end')
            if len(self.graph_.f_word.fav_list[rnd]) == 4:
                self.graph_.text_rus.insert('1.0', self.graph_.f_word.fav_list[rnd][1])
                self.graph_.text_eng.insert('1.0', self.graph_.f_word.fav_list[rnd][2])
                self.graph_.text_esp.insert('1.0', self.graph_.f_word.fav_list[rnd][3])
            elif len(self.graph_.f_word.fav_list[rnd]) == 3:
                self.graph_.text_rus.insert('1.0', self.graph_.f_word.fav_list[rnd][1])
                self.graph_.text_eng.insert('1.0', self.graph_.f_word.fav_list[rnd][2])
                self.graph_.text_esp.insert('1.0', 'None')

        elif (self.graph_.goBack.get()) == 'True':
            self.ind_backwards = self.ind_backwards - 1
            self.c.execute("select * from voc_table where rowid=%d" % self.total_count[self.ind_backwards])

            print('back: ', self.total_count[self.ind_backwards])
            temp_list = self.c.fetchone()
            try:
                self.graph_.text_rus.delete('1.0', 'end')
                self.graph_.text_rus.insert('1.0', temp_list[1])

                self.graph_.text_eng.delete('1.0', 'end')
                self.graph_.text_eng.insert('1.0', temp_list[2])

                self.graph_.text_esp.delete('1.0', 'end')
                self.graph_.text_esp.insert('1.0', temp_list[3])
            except:
                None

        else:
            self.ind_backwards = -1
            self.c.execute("select Count(*) from voc_table")
            lim_ = self.c.fetchall()
            self.rnd_for_continue = random.randint(1, lim_[0][0])
            print(lim_[0][0], ' - ', self.rnd_for_continue)
            self.total_count.append(self.rnd_for_continue)
            print('straight: ', self.total_count)
            self.c.execute("select * from voc_table where rowid=%d" % self.rnd_for_continue)
            temp_list = (self.c.fetchone())
            for str_ in temp_list:
                if '[' in str_:

            try:
                self.graph_.text_rus.delete('1.0', 'end')
                self.graph_.text_rus.insert('1.0', temp_list[1])
                self.graph_.text_eng.delete('1.0', 'end')
                self.graph_.text_eng.insert('1.0', temp_list[2])
                self.graph_.text_esp.delete('1.0', 'end')
                self.graph_.text_esp.insert('1.0', temp_list[3])
            except:
                None


def main():
    location_V1 = r'C:/C/V1.db'
    location_V3 = r'C:/C/V3.db'
    location_Voc_Compl = r'C:\Users\Denis\Desktop\IT\PYTHON\Vocabulario_Completo.docx'
    create_V3_combine_V3_with_V1 = Create_check_db(location_V1, location_V3, location_Voc_Compl)

    root = Tk()

    root.geometry('700x450+200+100')
    root.resizable(False, False)
    new_play = Graph(root)

    root.mainloop()


main()

